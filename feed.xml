<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Random coding knowledge</title>
  <subtitle></subtitle>
  <link href="https://thanos.codes/feed.xml" rel="self"/>
  <link href="https://thanos.codes"/>
  <updated>2020-05-31T01:00:00+01:00</updated>
  <id>https://thanos.codes</id>
  <author>
    <name>Thanos Papathanasiou</name>
    <email>thanospapathanasiou@hotmail.com</email>
  </author>
  
  <entry>
    <title>Implementing conditional resolution of dependencies with Castle.Windsor</title>
    <link href="https://thanos.codes/blog/implementing-conditional-resolution-of-dependencies-with-castle-windsor/"/>
    <updated>2020-05-27T01:00:00+01:00</updated>
    <id>https://thanos.codes/blog/implementing-conditional-resolution-of-dependencies-with-castle-windsor/</id>
    <content type="html">&lt;p&gt;Let’s say you are given the task of creating a console program to calculate the given element of the Fibonacci sequence.&lt;/p&gt;
&lt;p&gt;Great, that’s easy enough. You can just use your favorite tools: VS Code and dotnet core.&lt;/p&gt;
&lt;p&gt;You just open up your terminal, cd into the directory of your projects and type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;
mkdir DependencyInjectionPlayground
cd DependencyInjectionPlayground
dotnet new console
code .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After a little thinking you write the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;
using System;

namespace DependencyInjectionPlayground
{
    class Program
    {
        static void Main(string[] args)
        {
            var n = Convert.ToInt32(args[0]);
            var fibonacciCalculator = new FibonacciCalculator();
            var output = fibonacciCalculator.Calculate(n);
            Console.WriteLine($&amp;quot;The {n}-th element of the fibonacci sequence is {output}&amp;quot;);
        }
    }
 
    public class FibonacciCalculator
    {
        //Calculates the n-th element of the fibonacci sequence
        public long Calculate(int n)
        {
            if (n &amp;lt;= 2) return 1;
            return Calculate(n-1) + Calculate(n-2);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then click save and go back to the console.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;
dotnet build
dotnet run 5

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you get the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;
&amp;quot;The 5-th element of the fibonacci sequence is 5&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Job well done.&lt;/p&gt;
&lt;p&gt;That is until you realize that for large numbers it gets exponentially slower because of the nature of this recursive algorithm.&lt;/p&gt;
&lt;p&gt;The damn thing has a time complexity of O(2^n)&lt;/p&gt;
&lt;p&gt;As Rocky would say:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://thanos.codes/blog/implementing-conditional-resolution-of-dependencies-with-castle-windsor/images/rocky.png&quot; alt=&quot;Motivational Rocky!&quot;&gt;&lt;/p&gt;
&lt;p&gt;So, after you get your inspirational speech you go online and after some googling and Wikipedia reading you come across the article on Memoization.&lt;/p&gt;
&lt;p&gt;You update your algorithm to take advantage of your newfound knowledge:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;
public class MemoizedFibonacciCalculator
{
    private long[] memoized;
    private int current;

    public MemoizedFibonacciCalculator()
    {
        memoized = new long[32];
        memoized[0] = 0;
        memoized[1] = 1;
        memoized[2] = 1;
        current = 2;
    }

    //Calculates the n-th element of the fibonacci sequence
    public long Calculate(int n)
    {
        //if we have calculated the n-th element already, return it
        if (n &amp;lt;= current) return memoized[n];

        //if we haven&#39;t then resize the array to hold the new values.
        Array.Resize(ref memoized, n + 1);

        //Calculate all the elements between the currently calculated element
        //and the n-th element and then save them.
        for (int i = current + 1; i &amp;lt;= n; i++)
        {
            memoized[i] = memoized[i - 2] + memoized[i - 1];
        }

        current = n;
        return memoized[current];
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems that using our original recursive algorithm sacrifices cpu speed versus the updated algorithm using memoization which sacrifices ram.&lt;/p&gt;
&lt;p&gt;We don’t want to limit our users to one or the other as we don’t know where they are going to run this code.&lt;/p&gt;
&lt;p&gt;It seems we’ll have to provide them the option to choose the algorithm on runtime.&lt;/p&gt;
&lt;p&gt;This is where dependency injection comes into play. Switch to your trusty console and type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;
dotnet add package Castle.Windsor
dotnet restore
dotnet build

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After some reading of the Castle Windsor documentation you come across this interface: IHandlerSelector&lt;/p&gt;
&lt;p&gt;A “go to definition” returns this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    Summary:

    Implementors of this interface allow to extend the way the container perform component resolution based on some application specific business logic.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perfect.&lt;/p&gt;
&lt;p&gt;Let’s write a generic handler selector class that would allow us to apply basic selection criteria to the requested implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;
public class GenericHandlerSelector : IHandlerSelector
{
    private readonly Func&amp;lt;Type, bool&amp;gt; filter;
    private readonly Func&amp;lt;IHandler, bool&amp;gt; predicate;

    public GenericHandlerSelector(Func&amp;lt;Type, bool&amp;gt; filter, Func&amp;lt;IHandler, bool&amp;gt; predicate)
    {
        this.filter = filter;
        this.predicate = predicate;
    }

    public bool HasOpinionAbout(string key, Type service)
    {
        return filter(service);
    }

    public IHandler SelectHandler(string key, Type service, IHandler[] handlers)
    {
        return handlers.First(predicate);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basically allows the bootstrap container code to apply logic to what implementation of an interface the container is going to use.&lt;/p&gt;
&lt;p&gt;The code finally looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;
using System;
using System.Linq;
using Castle.Windsor;
using Castle.MicroKernel;
using Castle.MicroKernel.Registration;

namespace DependencyInjectionPlayground
{
    class Program
    {
        static void Main(string[] args)
        {
            bool useMemoization = Convert.ToBoolean(args[1]);
            var container = BootstrapContainer(useMemoization);

            var n = Convert.ToInt32(args[0]);
            var fibonacciCalculator = container.Resolve&amp;lt;IFibonacciCalculator&amp;gt;();

            var output = fibonacciCalculator.Calculate(n);
            Console.WriteLine($&amp;quot;The {n}-th element of the fibonacci sequence is {output}&amp;quot;);

        }

        static IWindsorContainer BootstrapContainer(bool useMemoization)
        {
            IWindsorContainer container = new WindsorContainer();

            container.Register(Component.For&amp;lt;IFibonacciCalculator&amp;gt;().ImplementedBy&amp;lt;FibonacciCalculator&amp;gt;());
            container.Register(Component.For&amp;lt;IFibonacciCalculator&amp;gt;().ImplementedBy&amp;lt;MemoizedFibonacciCalculator&amp;gt;());

            // filter -&amp;gt; this handler only affects implementations of IFibonacciCalculator
            // handler -&amp;gt; depending on input, choose the implementation we want
            var memoizationHandler = new GenericHandlerSelector(
                (filter) =&amp;gt; filter == typeof(IFibonacciCalculator),
                (handler) =&amp;gt; useMemoization
                    ? handler.ComponentModel.Implementation == typeof(MemoizedFibonacciCalculator)
                    : handler.ComponentModel.Implementation == typeof(FibonacciCalculator)
                );

            container.Kernel.AddHandlerSelector(memoizationHandler);

            return container;
        }

    }

    public class GenericHandlerSelector : IHandlerSelector
    {
        private readonly Func&amp;lt;Type, bool&amp;gt; filter;
        private readonly Func&amp;lt;IHandler, bool&amp;gt; predicate;

        public GenericHandlerSelector(Func&amp;lt;Type, bool&amp;gt; filter, Func&amp;lt;IHandler, bool&amp;gt; predicate)
        {
            this.filter = filter;
            this.predicate = predicate;
        }

        public bool HasOpinionAbout(string key, Type service)
        {
            return filter(service);
        }

        public IHandler SelectHandler(string key, Type service, IHandler[] handlers)
        {
            return handlers.First(predicate);
        }
    }

    public interface IFibonacciCalculator
    {
        //Calculates the n-th element of the fibonacci sequence
        long Calculate(int n);
    }

    public class FibonacciCalculator : IFibonacciCalculator
    {
        //Calculates the n-th element of the fibonacci sequence
        public long Calculate(int n)
        {
            if (n &amp;lt;= 2) return 1;
            return Calculate(n - 1) + Calculate(n - 2);
        }

    }

    public class MemoizedFibonacciCalculator : IFibonacciCalculator
    {
        private long[] memoized;
        private int current;

        public MemoizedFibonacciCalculator()
        {
            memoized = new long[32];
            memoized[0] = 0;
            memoized[1] = 1;
            memoized[2] = 1;
            current = 2;
        }

        //Calculates the n-th element of the fibonacci sequence
        public long Calculate(int n)
        {
            //if we have calculated the n-th element already, return it
            if (n &amp;lt;= current) return memoized[n];

            Array.Resize(ref memoized, n + 1);

            for (int i = current + 1; i &amp;lt;= n; i++)
            {
                memoized[i] = memoized[i - 2] + memoized[i - 1];
            }
            current = n;
            return memoized[current];
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we switch back to our trusty console and do a:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;
dotnet build
dotnet run 40 false
dotnet run 40 true

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The false/true is user input for the use or not of Memoization.&lt;/p&gt;
&lt;p&gt;Unless you are running this on a supercomputer, you’ll notice the difference in speed between the two algorithms.&lt;/p&gt;
&lt;p&gt;If you want to do a little bit of digging I’d suggest measuring the exact difference in the time it took to run both of these using System.Diagnostics&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Setting up eleventy to work with github pages</title>
    <link href="https://thanos.codes/blog/setting-up-eleventy-to-work-with-github-pages/"/>
    <updated>2020-05-31T01:00:00+01:00</updated>
    <id>https://thanos.codes/blog/setting-up-eleventy-to-work-with-github-pages/</id>
    <content type="html">&lt;p&gt;Ever since github started offering their GitHub Pages to use as a personal website for its users, I&#39;ve been interested in using them. I&#39;ve even tried setting mine up a couple of times but I always found that configuring jekyll and finding a proper theme that would play well with whatever versions of rubygems I already had was a pain.&lt;/p&gt;
&lt;p&gt;Furthermore, there was no reason in my mind to have yet another development environment (Ruby&#39;s) installed on my local machine and kept up to date so that I could write a blog post once in a blue moon.&lt;/p&gt;
&lt;p&gt;So, in the end, I never bothered with actually using my github page for quite some time.&lt;/p&gt;
&lt;p&gt;I do tend prioritize things lower if there is significant friction when doing something with them and blogging with the github pages had quite a bit of friction involved.&lt;/p&gt;
&lt;p&gt;It had been going like that for a while until a few days ago when I came across a youtube video about &lt;a href=&quot;https://www.youtube.com/watch?v=j8mJrhhdHWc&quot;&gt;setting up a static site with eleventy.&lt;/a&gt; The tool seemed to get out of your way as much as possible and allowed you to simply write your markdown files to be processed into pages.&lt;/p&gt;
&lt;p&gt;Within a few minutes I was convinced. I started yet again the process of setting up my github page and working with eleventy to create a decent static page as output.&lt;/p&gt;
&lt;p&gt;Everything was working just fine and dandy until the time came to actually have github host the pages that eleventy outputs. There were alot of websites documenting how to do this process but I found them to be either too complicated (setup github actions, CI servers, etc) or the result would not be clean enough (have the eleventy static site output commited to the same repository as the code).&lt;/p&gt;
&lt;p&gt;In the end, there was this &lt;a href=&quot;https://tomhiskey.co.uk/posts/deploying-eleventy-to-github-pages-one-way/&quot;&gt;blogpost by Tom Hiskey&lt;/a&gt; that mentioned in the TLDR:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;If you&#39;re trying to deploy an Eleventy site to GitHub Pages, one option is to build it locally and fiddle about with settings.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;But, as I already mentioned, I don&#39;t want to mix my static site (the output) with the code that is responsible for that (the input)&lt;/p&gt;
&lt;p&gt;So I did the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a base directory, let&#39;s call it &amp;quot;blog&amp;quot;&lt;/li&gt;
&lt;li&gt;Inside that directory we&#39;ll clone the github page, &lt;a href=&quot;https://github.com/ThanosPapathanasiou/thanospapathanasiou.github.io&quot;&gt;thanospapathanasiou.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;And we will also initialize another git folder called &lt;a href=&quot;https://github.com/ThanosPapathanasiou/personal-blog&quot;&gt;personal-blog&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Our folder structure will end up being like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./blog/
./blog/thanospapathanasiou.github.io (git repository 1)
./blog/personal-blog/ (git repository 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this folder structure, you can start writing your blogposts in the personal-blog folder and have eleventy running and serving them locally for any tweeks you might need to do before you commit them.&lt;/p&gt;
&lt;p&gt;Be careful though. If you want to keep things clean and separated like I do then you don&#39;t want to commit the static html output in the personal-blog folder, you want to commit them to your github page.&lt;/p&gt;
&lt;p&gt;The problem is that copying and pasting the changes from codingblog/_site/* to thanospapathanasiou.github.io/* can be such a pain.&lt;/p&gt;
&lt;p&gt;Thankfully the good ol&#39; Makefile comes to the resque! This is the &lt;a href=&quot;https://github.com/ThanosPapathanasiou/personal-blog/blob/master/Makefile&quot;&gt;one&lt;/a&gt; I wrote for my purposes.&lt;/p&gt;
&lt;p&gt;You basically need three things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clean the codingblog/_site/* so you start from an empty base.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rm -rf _site/*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Build your eleventy static site into codingblog/_site/*&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npx @11ty/eleventy eleventy --input=site --output=_site
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;finally, we need to copy that static file into our github pages folder.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First we need to clean up the github pages folder&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;find ../thanospapathanasiou.github.io/ -mindepth 1 ! &#39;(&#39; -path &#39;../thanospapathanasiou.github.io/.git/*&#39; -or -name &#39;.git&#39; -or -name &#39;CNAME&#39; &#39;)&#39; -delete
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Copy the output to the github page folder&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cp -a ./_site/. ../thanospapathanasiou.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Step 3.1 is a bit complicated so let&#39;s break it down a bit.&lt;/p&gt;
&lt;p&gt;Basically what we need to do is find all the items in the github page directory that are &lt;strong&gt;NOT&lt;/strong&gt; in its .git folder, are not the actual .git folder itself, or the CNAME file (that&#39;s the file that has the custom domain name your blog will point to)&lt;/p&gt;
&lt;p&gt;Now my proccess from creating a new blogpost is quite straightforward and with a lot less friction!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a folder with the blogpost&#39;s permalink in the &lt;code&gt;/personal-blog/site/blog&lt;/code&gt; folder.
Let&#39;s say that the name of that folder is &lt;code&gt;setting-up-eleventy-to-work-with-github-pages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;index.md&lt;/code&gt; file and start writing&lt;/li&gt;
&lt;li&gt;Open a terminal in the &lt;code&gt;/personal-blog/&lt;/code&gt; folder and run &lt;code&gt;make run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Have your browser navigate to &lt;code&gt;http://localhost:8080&lt;/code&gt; and watch it for anything not displaying correctly&lt;/li&gt;
&lt;li&gt;Once you are done with editing, run &lt;code&gt;make publish&lt;/code&gt; and the changes will appear in the github directory&lt;/li&gt;
&lt;li&gt;Commit and push the changes from both repositories&lt;/li&gt;
&lt;li&gt;Profit?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I&#39;ve found that the above proccess works really well for me, if you want to have a look at the repository for yourself then the link is &lt;a href=&quot;https://github.com/ThanosPapathanasiou/personal-blog&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Happy blogging!&lt;/p&gt;
</content>
  </entry>
</feed>